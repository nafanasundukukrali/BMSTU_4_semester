# 1.7. Множественное наследование. Прямая и косвенная базы. Виртуальное наследование. Понятие доминирования. Порядок создания и уничтожения объектов. Проблемы множественного наследования. Неоднозначности при множественном наследовании.

## Множественное наследование

В языке С++ используется множественное наследование. В современных языках от него отказались. 

Есть сущность C, и эту сущность хотим породить на основании A и B. Интерфейс - объединённый, но это не точно.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_1.png)

А если бы не было бы множественного наследования, как это было бы? А вот так вот было бы.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_2.png)

Однако, **у такой реализации интерфейсы от A -> B -> C может оказаться отличным, чем в первом примере по итогу, и лишаемся возможности работы с ссылкой на базовый класс**, а ведь, ещё по Хоару, код работающий с базовой сущностью должен поддерживать работу с производными.

Другой вариант без множественного наследования. Здесь класс C порождается от класса A и включает в себя класс B. Что означает включение? В классе C порождаются обёрточные методы, которые будут обращаться к объекту класса B. Всё ещё вопрос, а как же работать через ссылку с базовой сущностью B.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_3.png)

Вот такую задачу решает множественное наследование. 

## Прямая и косвенная база.

**Прямая база** - база, относительно которой сущность была порождена непосредственно. (на картинке ниже для В - А прямая база, для С - В прямая база). В производный класс прямая база может входить только 1 раз.

**Косвенная база** - база, которая входит в сущность, но от неё непосредственно не породились (прямая база прямой базы)). (на картинке ниже класс А для С - это косвенная база). Косвенная база в производный класс может входить сколько угодно раз.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_2.png)

Пример с косвенной и прямой базой.

```cpp
class A
{
public:
    A(const char* s) { cout << "Creature A" << s << ";" << endl; } // Нет конструктора по умолчанию
};

class B : public A
{
public:
    B() : A(" from B") { cout << "Creature B;" << endl; }
};

class C : public B, public A
{
public:
    C() : A(" from C") { cout << "Creature C;" << endl; }
};

int main()
{
    C obj;
}
```

## Виртуальное наследование

Чаще всего нужна вот такая вот (ромбовидная) схема. Для её реализации используют виртуальное наследование.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_4.png)

```cpp
#include <iostream>

using namespace std;

class A
{
public:
    A(const char* s) { cout << "Creature A" << s << ";" << endl; }
};

class B : virtual public A
{
public:
    B() : A(" from B") { cout << "Creature B;" << endl; }
};

class C : virtual public A
{
public:
    C() : A(" from C") { cout << "Creature C;" << endl; }
};

class D : public B, public C
{
public:
    D() : A(" from D"){ cout << "Creature D;" << endl; }
};

int main()
{
    D obj;
}
```

Механизм виртуальности включается при первом определении этого класса. 

**ВНИМАНИЕ! К. Л. показал пример. Его написали как ниже, запустили, рез не тот же.**

* В D public B, public C; В B virtual public A; В C vitual public A;
```
Creature A from D;
Creature B;
Creature C;
Creature D;
```
* В D virual public B, virtual public C; В B virtual public A; В C vitual public A; аналогично
* В D public B, public C; В B public A; В C vitual public A;
```
Creature A from D;
Creature A from B;
Creature B;
Creature C;
Creature D;
```
* В D virtual public B, virtual public C; В B public A; В C vitual public A;
```
Creature A from B;
Creature B;
Creature A from D;
Creature C;
Creature D;
```
* В D public B, public C; В B virtual public A; В C public A;
```
Creature A from D;
Creature B;
Creature A from C;
Creature C;
Creature D;
```
* В D virtual public B, virtual public C; В B virtual public A; В C public A; аналогично
* В D public B, public C; В B public A; В C public A; (убираем вызов конструктора A в D)
```
Creature A from B;
Creature B;
Creature A from C;
Creature C;
Creature D;
```
* В D virtual public B, virtual public C; В B public A; В C public A; (убираем вызов конструктора A в D), аналогично

Когда реализуется класс D, а конструктор C не имеет конструктора по умолчанию, то в конструкторе D необходимо вызывать конструктор класса А.
Если иерархия большая, то это становится проблематичным. Таким образом, при множественном наследовании при создании произвольного класса необходимо думать о всей иерархии.

**Если класс является наследником, как виртуальных баз, так и нет, то конструкторы виртуальных баз отрабатывают в первую очередь.**

## Понятие доминирования

Методы, определяемый в производных классах доминируют над такими же методами, созданными в базовом классе.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_5.png)

**Зачем так сделали?** Когда перегружаются методы с одним и тем же именем, то подразумевается, что они делают одно и то же, но просто принимают разные данные, но работают с членами-данными одно и того же объекта. А если понадобилось задать метод в производном классе с таким же именем, то есть вероятность, что он будет работать только с членами-данными объекта производного класса.

Решение, если надо, то же, что и при изменении уровня доступа членов класса (но это не рекомендуется по той же причине):

```cpp
class B : public A
{
public:
    void f(int i);
    using A::f;
};
```

В общем случае, граф наследования - направленный ациклический граф. Тот метод, который определён ниже по графу доминирует над тем методом, который определён выше. Так, на обоих приведённых ниже графах доминирует метод f() из класса B, он будет использован, соответственно, в классах C и D. Это влияет на порядок создания объекта.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_6.png)

## Проблемы множественного наследования. Неоднозначности при множественном наследовании

### 1

Основная идея в наследовании - есть класс А, от него делаем производный класс B. Говорят, что делается надстройка над базовым классом. 

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_7.png)

И здесь при множественном наследовании возникают проблемы.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_7_8.png)

На приведённой выше картинке draw прорисует часть D, B, C и дважды A. И нормальных решений этой проблемы нет. Раньше решали это так:
```cpp
class B : public A
{
protected:
    void _draw();
public:
    void draw();
};
```
И в _draw() отрисовывается только та часть, которая непосредственно относится к этому же объекту, а draw() вызывает protected-методы, то есть формирует то, в котором порядке будет формироваться изображение. И опять же нужно знать всю иерархию.

### 2

В разных классах могут быть поля-члены с одинаковыми именами, причём эти члены могут быть разного типа, разного уровня доступа, перегрузки. И проблема заключается в том, что проверка на неоднозначность осуществляется до проверки уровня доступа, типа, перегрузки. Опять же, если иерархия классов большая, то сложно разбираться с неоднозначностью.
