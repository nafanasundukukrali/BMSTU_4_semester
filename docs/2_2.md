# 2.2. Преимущества и недостатки структурного программирования. Идеи Энтони Хоара. Преимущества и недостатки объектно-ориентированного программирования.

## Плюсы СП

* Исправление логических ошибках на самых ранних стадиях разработки. 
* Обеспечивается комплексная отладка.
* Возможность совмещения этапов планирования, кодирования, тестирования.
* Повторное использование кода.
* При таком подходе почти нет "кода в корзину".
* Основные логические ошибки на ранних стадиях, то проект оканчивается плавно (кода в конце если и много, то он простой и не содержит логику).
* За счёт ИБЛС упрощается чтение кода.
* С самого начала тесное взаимодействие с заказчиком. 
* Иерархическая структура, дающая множество естественных контрольных точек. (контрольные точки != контрольные сессии, точек больше).
* Легко происходит локализация ошибки (за счёт кол-во контрольных точек).
* Отказ проекта стремится к 0.

## Минусы СП

* Понижение надежности за счет внесения изменений в написанный чужой код (плюс трата времени на разбор чужого кода), поскольку чаще всего программисты уходят в другие проекты. Добавление нового функционала тянет за собой изменение структур данных, а с этими данными возможно уже была работа в другом месте. Изменение данных ведёт к смещению уровней абстракции. ** Любое изменение написанного кода - понижение его надёжности. **
* Очень много времени уходит на разбор чужого кода. Наступает момент, когда проще всё заново написать.
* Исключительные ситуации обрабатываются вперемешку с логикой кода - это приводит к большому количеству проверок и необходимости "протаскивать" ошибку через весь код до того места, где её можно будет обработать.

## Идеи Энтони Хоара "Совместное использование записей"

1. Есть проблема, есть модификация, модификация приводит к изменению данного => перелопачиваем код. Идея: изначально выделим, что можно делать с этим данным (данное? Ну короче про данные). Данное не трогаем, взаимодействуем с ним только за счёт выделенных действий. (в дальнейшем эту идею назвали инкапсуляцией)
2. Внесение изменений в написанный код ведет к понижению надёжности. Идея: если надо что-то изменить, то делаем настройку над уже написанным кодом (добавляем новые поля, настройку над уже имеющимися действиями надстройку). (в дальнейшем эту идею назвали наследованием) + мы же не хотим изменять тот код, который уже ранее написан -> старый код должен иметь возможность работать с новым объединением. (в дальнейшем эту идею назвали полиморфизмом)
3. Идея: в физическом мире объекты взаимодействуют между собой. Это взаимодействие переносим в язык. Пускай объекты взаимодействуют также как в физическом мире. В ФМ два вида взаимодействия: 
* Аксессорное взаимодействие (синхронное) - если нужна информация извне, то её можно получить, если надо. (get, set)
* Событийное взаимодействие (ассинхронное) - в ФМ происходят инциденты, и какие-то объекты меняют свои свойства.

## Минусы ООП

1. Надо сначала хотя бы построить начальную модель, код пишется только после. Рекурсивный дизайн - начальную модель построили, потом её разворачиваем.
2. Другая квалификация разработчика.
3. Другая декомпозиция задачи (выделяем понятия и строим их взаимодействия).
4. Увеличивается количество кода.
5. Нужно больше памяти.
6. Программа выполняется в несколько раз медленнее. 
7. В СП мёртвого кода почти нет, а тут его очень много из-за настройки, в связи с которой прекращается использование чего-то.

## Плюсы ООП

1. Легко модифицируется уже написанный код.
2. Более "естественная" декомпозиция ПО, которая существенно облегчает разработку.
3. Сокращение количества межмодульных вызовов и уменьшение объемов информации, передаваемой между модулями.