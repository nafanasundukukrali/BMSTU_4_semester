# 1.12. Шаблоны функций, методов классов и классов в С++. Недостатки шаблонов. Параметры шаблонов. Параметры типы и параметры значения. Шаблоны функций и методов классов. Подстановка параметров в шаблон. Выведение типов параметров шаблона. Явное указание значений типов параметров шаблона при вызове функции. Срезание ссылок и модификатора const.

Проблема: надо выполнять одни и те же действия над данными одного и того же типа, предотвращать дублирования кода.

Пути:
1. void* - зло
2. Макрос с параметрами - так делали, но там нет проверки макроса на этапе препроцессирования, трудно локализировать ошибку. 
3. Шаблон

Шаблон — это конструкция, которая создает обычный тип или функцию во время компиляции на основе аргументов, которые пользователь предоставляет для параметров шаблона. Если шаблон не используется, то компилятор его не проверяет. Шаблон - возможность реализовать в первую очередь что-то для разных типов, однако параметрами шаблона также могут быть параметры-значения.

Шаблоном может быть:
1. Функция
2. Тип
3. Класса, и класса, если он не шаблонный, может быть шаблонный метод, или и то, и то.

## Недостатки шаблонов
1. Компилятор полностью не проверяет шаблон, только на синтаксис. А вот передали параметр какого-то типа, а про этот тип компилятор ничего не знает, поэтому это проверить он не в состоянии. Просто просматривает шаблон. Компилятор не компилирует шаблон. Код создаётся при чётком указании значений параметров шаблона. В современных языках есть такое понятие, как обобщение, generic. Это тот же самый шаблон, но точно накладываются ограничения на типы параметров шаблона, а поскольку компилятор точно точно знает эти ограничения, то он может это скомпилировать. На шаблоны можно задать ограничения, но строгое выполнение этих ограничений не накладывается на шаблон. 
2. низя откомпилировать -> шаблоны нельзя располагать в файлы реализации. Поэтому вынуждены всё определять в заголовочных файлах.
3. Начинаем использовать шаблоны, а программа начинает компилироваться очень долго, поскольку компилятору сложно работать с шаблоном. Шаблоны можно специализировать, компилятор начинает делать так: подставил не работает, иду дальше, подставил, не работает, илу дальше и т.д...

> Метапрограммирование - всё хотят по максимуму перенести на этап компиляции. 

## Параметры шаблонов. Параметры типы и параметры значения.

#### Тип

Типовым параметром шаблона может быть простой тип (вообще это класс теперь), производный тип, класс.

Типовой параметр шаблона начинается или со слова class, или со слова typename `typename <name>`, `class <name>`.

#### Значения

Параметры значения могут быть либо целый тип, либо символьный, либо указатель. Указатели должны быть со внешним связыванием (указатель вообще чего-то внешнего, то есть не на стеке), а остальные значения - инициализированы, константы, литералы. В 20й стандарт добавили возможность вещественных типов параметров-значений, но не все компиляторы это поддерживают, связано с тем, что не все с такой возможностью согласны, поскольку вещественный - тип с частичным упорядочиванием. 

## Шаблоны функций и методов классов. Подстановка параметров в шаблон. Выведение типов параметров шаблона. Явное указание значений типов параметров шаблона при вызове функции.

Объявление шаблонной функции:
```cpp
template <typename T>
void swap(T &t1, T &t2);

in a = 0;
int b = 1;
swap(a, b);

double c = 7;
swap(a, c); // А попытается поискать, а напишет, что такого шаблона нет.
```

Как использовать этот шаблон? Компилятор, когда будет происходить вызов функции, попытается подставить параметры в шаблон, а и вообще во все попытается, выберет тот, который более конкретен для этих параметров. А ещё может быть конфликт шаблонов (по аналогии с перегрузкой функции). И если они подойдут, то всё будет нормально.

Решение проблемы такого поиска - явно указать тип, по которому будет происходить подстановка. `swap<double>(a, c); // Всё ок`.

Другой вариант, для конкретного типа указать, что будет параметром шаблона.

```cpp
template <typename T>
void swap<double>(double &t1, double &t2);
```

## Срезание ссылок и модификатора const

При подстановки параметров происходит свёртывание ссылок, и в некоторых ситуациях убирается модификатор const при передачи параметров. 

Есть такой шаблон функции.

```cpp
template <typename T>
T f(T v) {return v;} // 1
template <typename T>
T f(T &v) {return v;} // 2
template <typename T>
T f(const T &v) {return v;} //3
...
int i;
int &i = i;
const int &b = 0;

f(i); // 1: Здесь происходит выведение типа, то есть передаётся параметр типа int, логично что T будет выведен как int. 
// 2: принимает как ссылка на тип. А раз ссылка, то не должно быть копирование int f<int>(int & v);
// 3: int f<int>(const int &v);
f(a); // 1: произойдёт срезание ссылки.
// 2: int f<int>(int & v)
// 3: int f<int>(const int &v);
f(b); // 1: вообще спилит и const заодно
// 2: int f<const int>(const int &v);
// 3: int f<const int>(const int &v);
```

А вот в двадцатом всё можно упростить в...

```cpp
auto f(auto v) {return v;};

int main()
{
    int i = 8;
    int &a = i;
    const int &b = 0;

    f(i);
    f(a);
    f(b);
}
```

А это называется **неявным шаблоном**.