# 2.1. Структурное программирование: нисходящая разработка, использование базовых логических структур, сквозной структурный контроль.

## Увертюра

> Думай всегда о главном, разделяй и властвуй (С)

* Технология появилась в 61 году (идеи о о пэ 66)

В 50х возникла необходимость написания больших программ. Проблемы: невозможно определить сроки выполнения работ, сколько нужно программистов, плохая читабельность кода, надёжность ПП низкая. В 61г. IBM: мы разработали методы и приёмы, которые позволят повысить производительность программиста на порядок, ПП будет без ошибок. Сначала технологию звали "усовершенствованные методы программирования", а затем "технология структурного программирования".

**Декомпозиция** - идея разделения задачи по подзадачи.

**Методология** - определяет набор приёмов и методов, которые объединены единым философским подходом. В программировании 4 подхода: 
1. Алгоритмическая декомпозиция - задача разбивается на подзадачи по действиям (что нужно сделать?). Язык Си относится к группе процедурных языков.
2. Декларативный подход - декларируем правила и задачу накладываем на свод правил или законов. Нельзя определить как будет работать вычислительный процесс, всё зависит от накладываемой задачи. Маленькие задачи чил решаются, с большими проблема. 
3. Функциональный подход - описываем что-либо набором функций. Основная идея - функция имеет всегда однозначный ответ. В языке С++ есть функциональные элементы.
4. ООП. Объектная декомпозиция.

***

### Основные идеи:
1. Нисходящая разработка.
2. Использование базовых логических структур.
3. Сквозной структурный контроль.

### Этапы:
1. Анализ.
2. Проектирование.
3. Кодирование.
4. Тестирование.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/2_1_1.png)

На этапе анализа происходит формализация задачи, а выходе получаем техническое задание и должны понять, формализуема ли задача вообще, а также идёт оценка трудозатрат: сколько времени, программистов, средства на разработку ПО. Главное - получение ТЗ.

На этапах проектирования, кодирования, тестирования используется **нисходящий подход**. Идём о общего к частному. Есть задача, эту задачу разбиваем на подзадачи по действиям (что нужно сделать? Это, это, это. Задачи 1, 2, 3.). 

Структурное программирование использует подход чёрного ящика. Используя подзадачи как чёрные ящики можно разработать алгоритм основной задачи. Алгоритм кодируем, переходим к тестированию. На тестировании закрываем зависимые функции данными, которые берутся на основе тестов, которые пишутся на основе ТЗ. **Заглушка** - то, что должна выдавать функция при данных входных данных. Процесс получения ТЗ может быть безумно долгим. Оно должно быть очень подробным, бесконечная формализация всех моментов, и до конца всё не будет формализовано. Некоторые вещи вы подумаете так и не укажите, а заказчик тоже думает, что это очевидно и не будет писать. 

**Планировщик** - конспект всей задачи.

В дальнейшем задачу разбиваем на ещё более мелкие, для них повторяем этапы: реализовываем алгоритм, кодируем, заглушки, тестируем. Уровни декомпозиции - контрольные точки. Чем больше точек - тем легче взаимодействовать с заказчиком.

Когда выделили действие стремимся ограничивать сложность действия. используем сегментирование, то есть стремимся разбить действие на логические куски (сегменты), причём сегмент может быть как кусок самой функции, так и выделить в отдельную функцию (последнее позволяет её повторно использовать, проще отлаживать, возникает контрольная точка (нагляднее будет), чётко видим что передаём и что получаем). Желательно, чтобы один сегмент помещался на экран, чтобы была сразу понятна его логика. Код должен читаться сверху-вниз.

Зависимая задача не должна принимать решение функцию более высокого уровня.  У одной задачи не может быть более 7 подзадач.

Одна функция не должна выполнять несколько задач. 

### Что даёт такой подход?

* Разработка идёт сверху вниз, логика находится на высоком уровне, логические ошибки исправляются на начальном этапе. 
* Параллельно кодируем, проектируем и тестируем.
* При разработке подзадач абстрагируемся от подзадач того же самого уровня, более высокого и к зависимым подходим как к чёрным ящикам. 
* Можно при таком подходе взаимодействовать с заказчиком, причём плотно, (сделали - показали), заказчик видит, что вы работаете. 
* Внизу простые функции, не содержащие почти логику, из них можно делать библиотеки, которые можно потом использовать в других проектах.
* Так как для функция выделяем простые формулировки (действия), то можно легко проанализировать, есть ли похожие формулировки-действие. Отсутствие дублирования кода.
* Дерево задач растёт в глубину => больше уровней абстракций => больше контрольных точек наблюдения за проектами.

### Использование базовых логических структур

Идея - сводим количество логических конструкций языка к достаточному минимуму. Меньше конструкций - проще пистать программы.

Выделенные конструкции:
1. Ветвление, между двумя альтернативными и множественный выбор.
2. 4 конструкции цикла: цикл с предусловием, с цикл с постусловием, цикл со счётчиком, безусловный цикл (loop). Правило структурного программирования - выход из цикла должен быть только 1. 
3. В цикле должна быть только повторяющаяся часть. ООП добавляет ещё один цикл for each.

Возможна вложенность этих конструкций, вложенность ограничивается цифрой 3, она определяется при пошаговой детализации, то есть на этапе разработки алгоритма.

> Структурное программирование - программирование без go to. Ориентированно программирование - без switch.

### Сквозной контроль

IBM: на руководителе лежит 2 функции: раздать задачу и проконтролировать её решение. Идея: перенести функцию контроля на самих программистов. Реализовывается это: если ошибке на этапе разработки - это хорошо, а если ошибки релиз-версии - наказание рублём. Технические средства исправления ошибки - контрольные сессии. 

Цель контрольных сессий - выявление ошибок. Программист сам проводит сессию, поскольку в ней заинтересован. В контрольной сессии участвуют программисты из группы, решающей задачи, представители заказчика, люди, которые находят ошибки в коде из команды особенно. Руководство не приглашается, поскольку задача сессий - выявление ошибок, а не оценка программиста. 

Организация работы: надо, чтобы программисты взаимодействовали друг с другом -> сажаем их вместе, организуем рабочее пространство так, чтобы все программисты видели друг друга. 

Плюсы: все контролируют друг друга, все видят как работают коллеги (учимся у своих коллег - коллеги у вас), готовые решения без подводных камей есть у всех, легче выявляются недочёты вне контрольных сессий. Производительность быстро растёт, пока не наступает насыщение (все узнают друг друга, теряется чувство опасности, теряется контроль). Решение - перетасовать участников проекта, контракт с сотрудником на недолгий срок. 

***

## Дополнение

Поход **чёрного ящика** - нам не важно от задач как они что делают, нам важно что они делают, абстрагируемся от реализации этих задач, важно только то, что на входе и что на выходе. Важно понимать что передаём функции и понимаем, что она возвращает. Все данные передаём через список параметров, даже если это константа (ну не типа PI). 

Правила: 

1. Поскольку не задумаемся о реализации чёрного ящика нельзя думать за этот чёрный ящик (каждый думает сам за себя).
2. Поскольку не думаем за других, полное недоверие к данным, полученным из ящика. 

### Данные

Три группы:
1. Входные (in), подразумевается, что это данные, которые передаём. Функция ни в коем случае не должна их менять!
2. Выходные (out) - данные которые возвращаем. Если они переедаются через параметры, то они не инициалиазируются изначально, инициализация внутри функции.
3. Изменяемые (variable) - тонкий момент, они обязаны быть инициализированы, если функция не может выполниться, то она их не должна менять.

Функция не должна захватывать ресурсы, если она не может выполниться! Если функция выполняется, и захватывается ресурс, то этот ресурс функция должна вернуть на более высокий уровень. 

Нужно стремиться ограничивать количество передаваемых параметров (это не касается низкоуровневых функций). В функциях высокого уровня передавать не более трёх параметров. Объединяем в структуру логически связанные параметры. Во функцию нельзя передавать ничего лишнего. 
Поля структур могут быть структурами. 

Возникает иерархия по данным. Иерархия по данным должна совпадать с иерархией по действиям! В противном случае возникает смещение уровней абстракции. На данным уровне мы не должны работать с полями полей структуры. 