# 1.16. Проблемы с динамическим выделением и освобождением памяти. Шаблон Holder. «Умные указатели» в С++: unique_ptr, shared_ptr, weak_ptr. Связь между shared_ptr и weak_ptr.

## Проблемы с динамическим выделением и освобождением памяти.

```cpp
{
    A *p = new B;
    p->f(); // Здесь возникает ошибка, p -> утечка памяти
    delete p;
}
```

Пути решения тут:
1. Поймать исключение, обернуть, и прокинуть дальше, когда будет можно.
2. Пообещать, что не будем кидать исключение.
3. Объект размещать на стеке. Но это плохо, поскольку если объект локальный и он нам больше не нужен, то ок, а если объекты между собой связаны, то плохо. 

# Шаблон Holder

Идея: указатель обернуть в статический объект, и в деструкторе этот объект будет уничтожаться.

```cpp
{
   Holder<A> obj(new A);
   obj->f();
}
```

Holder - это стандартный паттерн проектирования хранитель. Обеспечивает отсутствие утечки памяти. Он должен содержать конструктор, принцимающий указатель на объект, причём желательно, чтобы этот конструктор вызывался явно; конструктор копирования удалить, переноса оставить, оператор присваивания удалить. Холдер должен быть прозрачной оболочкой, поэтому перегружаются -> и *. А ещё нужно перегружать bool. Последнее - божия троица для этого паттерна.

Однако холдеру всё равно, динамическая память или статическая. Он отработает и попытается удалить память из кучи, а объект не в куче -> ошибка.

Во все библиотечные классы добавляется метод release - попользовался и отдай). 

```cpp
# include <iostream>

using namespace std;

template <typename Type>
class Holder
{
private:
    Type* ptr{ nullptr };

public:
    Holder() = default;
    explicit Holder(Type* p) : ptr(p) {}
    Holder(Holder&& other) noexcept
    {
        ptr = other.ptr;
        other.ptr = nullptr;
    }
    ~Holder() { delete ptr; }

    Type* operator ->() noexcept { return ptr; }
    Type& operator *() noexcept { return *ptr; }
    operator bool() noexcept { return ptr != nullptr; }

    Type* release() noexcept
    {
        Type* work = ptr;
        ptr = nullptr;

        return work;
    }

    Holder(const Holder&) = delete;
    Holder& operator =(const Holder&) = delete;
};

class A
{
public:
    void f() { cout << "Function f of class A is called" << endl; }
};

int main()
{
    Holder<A> obj(new A{});

    obj->f();
}
```

Раньше использовался жадный подход, то есть передали куда-то указатель, и тот объект начинает считать, что это её указатель, подобно хранителю. Умирая -> тянет за собой. 

Проблема - ситуация, когда есть объект, а другие объекты держат указатель на этот объект, поскольку он умрёт -> куча висячих указатель. Не понятно, когда будет ответственным за объект, кто его будет уничтожать.

Идея: последний уничтожаемый связанный объект должен уничтожать этот объект. А ещё неплохо, если была бы возможность проверка, а существует ли объект вообще.

До 11 стандарта был std::auto_ptr. Что-то типа холдера, но лучше. Но его почти невозможно было использовать. В 11 стандарте заменили этот указатель на 3 "умных".

## Умные указатели C++: unique_ptr, shared_ptr, weak_ptr. Связь между shared_ptr и weak_ptr.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_16_1.png)

### unique_ptr

Единственный уникальный. Тот же самый холдер по существу. 
* Решает задачу утечки памяти. 
* Предлагает только единоличное владение. 
* Нельзя копировать. 
* Можно перенести. 
* Можно отобрать - метод release. 
* Есть метод get, но его лучше не использовать.
* ->, *, bool
* Можно отдать в unique_ptr другой указатель, и это предполагает, что объект, на который уже указывает указатель, должен быть уничтожен. Метод reset (или ничего, или новый указатель принимает)
* swap (два uniqie_ptr могут обменяться объектами)
* Можно хранить не один объект, а несколько. Но так не хорошо. У него есть специализация для массива. `unique_ptr<T[]>;`. В этой специализации добавляется оператор [].
* Можно контролировать память, то есть на стек или на кучу указывает указатель с помощью обёртки deleter.

```cpp
# include <iostream>
# include <memory>
# include <stdio.h>

using namespace std;

# define V_1

# ifdef V_1
class Deleter
{
public:
void operator ()(FILE* stream) noexcept
{
fclose(stream);
cout << "file is closed" << endl;
}
};

# elif defined(V_2)
using Deleter = decltype([](FILE* stream)
{
fclose(stream);
cout << "file is closed" << endl;
});

# endif

using FilePtr_t = unique_ptr< FILE, Deleter >;

FilePtr_t make_file(const char* filename, const char* mode)
{
FILE* stream = fopen(filename, mode);

if (!stream) throw runtime_error("File not found!");

cout << "file is open" << endl;

return FilePtr_t{ stream };
}

int main()
{
try
{
FilePtr_t stream = make_file("test.txt", "r");
}
catch (const runtime_error& ex)
{
cout << ex.what() << endl;
}
}
```
* Очень лёгкий объект. Занимает размер указателя.

### shared_ptr

Совместный. "последний гасит" свет. Есть счётчик.

* Тяжёлый объект. 
* Поскольку совместное владение -> считаем сколько объектов владеют.
* Держит указатель на область памяти, которой владеет (object). Счётчик - отдельный объект во внешней памяти (count). 
* Извне голым объектом не работаем, только в оболочке shared. 
* Счётчик с появлением нового shared увеличивается.
* Объект уничтожается тогда, когда счётчик становится равным 0.
* Операторы те же самые. С 17-го есть специализация [].
* Копировать можно. Переносить можно. Присваивать. 
* release нет, а reset есть. reset() - счётчик уменьшится или освободится память.
* указатель, и он не один. Хотелось бы узнать сколько их таких? use_count метод.
* uniqie - возвращает, 1 ли счётчик или нет.
* есть конструктор, принимающий week_ptr.

### week_ptr

Слабое владение, это указатель, который не отвечает за объект: проверяет есть или нет объект.

* week_ptr связывают с shared_ptr, поскольку необходимо знать, существует ли объект. Он создаётся на основе shared и наоборот. Иначе говоря, он тоже держит указатель на эти области памяти. 
* На один объект может быть несколько week. Он понимает, если счётчик равен 0, то объект не существует. А если shared не создавали, то кто-то тем не менее должен захватить память. 
* На самом деле в счётчике хранится не один счётчик, а два. Один на количество shared, а другой на количество week. И когда и один и тот становится равен 0, тогда память из-под счётчиков можно освободить.
* если хотим с этим объектом работать, то приходит порождать на основании этого указателя порождать shared. Операций *, ->, bool нет. 
* use_count, reset, expired, проверяющий, а вообще есть ли объект или нет. 
* для поработать с объектом = породить shared -> lock()

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_16_2.png)

* у unique и shared есть шаблонный метод make_unique | make_shared. Эти шаблоны себе инкапсулируют оператор new. Но с make_shared есть одна проблема: если его использовать, то и счётчик, и объект будут храниться в одной области памяти. И из-под объекта, в этом случае, память будет освобождаться только тогда, когда оба эти счётчика станут равны 0.