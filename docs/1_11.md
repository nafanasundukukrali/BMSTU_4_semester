# 1.11. Перегрузка унарных и бинарных операторов. Проблемы с перегрузкой операторов &&, ||, ,, &. Перегрузка операторов ++, --. Перегрузка операторов приведения типов. Тривалентный оператор spaceship.

## in previous episodes

Унарные операторы можно перегружать как внешние, так и как члены класса, но желательно как члены класса. Бинарный оператор можно перегружать как член, и есть ситуации, когда надо перегружать как внешние.

## example
```cpp
class Complex
{
    double real, i;
public:
    bool operator == (const Complex&) const;
    friend bool operator == (const Complex &c1, const Complex &c2); // Друзья для такого класса не нарушат целостность объекта
    // Необходимость здесь друзей, поскольку хотим коммутативность операции a + 2 || 2 + a
    // Есть ещё необходимость перегружать бинарные операторы как вешние.
    // Если класс уже написан, хочется добавить функционал -> перегружаем внешний оператор (<<, >> для потоков)
};
```

## Проблемы с перегрузкой операторов `&&`, `||`, `,`, `&`

Проблемы с этим оператором:
1. В Си нет **ленивого вычисления** (стратегия вычисления, согласно которой вычисления следует откладывать до тех пор, пока не понадобится их результат), кроме && (если левый операнд ложь, то второй не вычисляется) и ||  (по аналогии). Если эти операнды перегружаем, то второй операнд будет вычисляться всегда. 
2. `,` - бинарный оператор, выполняющийся слева-направо, вычисляется левый операнд, потом правый операнд, результатом является значение правого операнда -> при перегрузке необходимо возвращать ссылку на правый операнд.
3. `&` - унарный оператор получения адреса. Если его перегрузить, то придём к тому, что адрес объекта не получится получить. Дали возможность, поскольку никому нахрен не сдался ваш этот адрес, а если очень надо получить адрес, то есть шаблон `std::addressof`, который получает адрес любого объекта и объекта с перегрузкой этого оператора тоже. Более того, очень часто запрещают получать адрес объекта, даже часто делают такой оператор как удалённый или приватным, ведь если извне можно брать адрес объекта, то можно взять указатель, а вам зачем указатель? Указатель - зло.

## Перегрузка операторов ++, --.

У них есть префиксная и постфиксная запись. До 11 стандарта можно было это перегружать, но различия между префиксной и постфиксной записью убирались. Был введён синтаксический сахар.

```cpp
class A
{
    int a;
public:
    A& operator++()
    {
        ++a;
        return *this;
    } // Раньше это заменяло как пост-фиксную, так и префиксную
    // Если оставить только этот вариант, то это тоже заменит, но как до 11 стандарта будет работать ++obj всё будет
    A operator++(int)
    {
        A temp(*this);
        ++a;
        return temp;
    } // obj++. Рассматриваем постфиксный как бинарный (а вот он сахарок)))
};
```

Для простых типов ++и и и++ всё равно, а для объектов ++объект, потому что в объект++ создаётся временный объект, происходит копирование.

## Перегрузка операторов приведения типов.

Он перегружается ТОЛЬКО как член класса.

```cpp
class A
{
    int a;
public:
    ...
    operator int() {return a;} // A obj; if(obj) будет неявное приведение к типу int
    explicit operator B() {return a;} // Правда может быть конфликт с конструкторами, поскольку запись B(<пар.>) может относиться как к конструктору, так и к оператору приведения типа.
};
```

В принципе можно привести к любому типу, поскольку конструктор, принимающий 1 параметр по сути является оператором приведения типа. Цепочки приведения типов делать нельзя. А ещё неявное приведение типа вроде как зло, так что explicit.

## Тривалентный оператор spaceship.

При сравнении получаются результаты отр., 0., полож., тернарная логика. При опредлении класса приходится заботиться о куче операторов: <, <=, ==, >=, >, !=. В 20-м стандарте появился оператор spaceship, `<=>`. Этот оператор для большинства ситуаций можно задать по умолчанию. Таким образом можно определить операторы <, <=, >=, >. Также с 20-го стандарта, если определить оператор ==, то оператор != генерится по умолчанию на основе оператора равно.

```cpp
class A
{
private:
    int a;
public:
    auto operator <=> (const A &) const = default; // Оператор возвращает не число, а объект опр. класса.
    // Если b приводится к a, то (a <=> b) @ 0, где @ - любая опр. срав., а если наоброт 0 @ (b <=> a)
};
```

Оператор не относится к ==, !=, поскольку различаются такие понятия, как сравнение на равно и эквивалентность. Эквивалентность - одно можно заменить другим, но не обязательно равно.

Возможны 3 типа, которые возвращает оператор:
1. strong_ordering - например int - однозначно происходит сравнение, есть равенство. Возвращает 3 варианта.
2. week_ordering - возвращает 3 варианта, 
3. partial_ordering - например float, где есть значения не равные, а эквивалентные (-0, 0), есть несравнимые величины, возвращает 4 варианта: меньше, больше, равно, не сравнимое.

```cpp
# include <iostream>
# include <compare>

using namespace std;

class MyInt
{
private:
    int value;

public:
    MyInt(int val = 0) : value(val) {}

    //strong_ordering operator <=>(const MyInt& rhs) const
    //{
    //    return value <=> rhs.value;
    //}

    //strong_ordering operator <=>(const MyInt& rhs) const
    //{
    //    return value == rhs.value ? strong_ordering::equal :
    //            value < rhs.value ? strong_ordering::less :
    //                                strong_ordering::greater;
    //}
     
    //weak_ordering operator <=>(const MyInt& rhs) const
    //{
    //    return value == rhs.value ? weak_ordering::equivalent :
    //            value < rhs.value ? weak_ordering::less :
    //                                weak_ordering::greater;
    //}

    partial_ordering operator <=>(const MyInt& rhs) const
    {
        return value == rhs.value ? partial_ordering::equivalent :
            value < rhs.value ? partial_ordering::less :
            value > rhs.value ? partial_ordering::greater :
            partial_ordering::unordered;
    }

    bool operator ==(const MyInt&) const = default;
};

int main()
{
    MyInt a{ 1 }, b{ 2 }, c{ 3 }, d{ 1 };
    cout << "a < b: " << (a < b) << ", c > b: " << (c >= b) << endl;
    cout << "a < b: " << (a < b) << ", c > b: " << (c > b) << ", a != b: " << (a != b) << endl;
    cout << "a < 5: " << (a < 5) << ", 1 < c: " << (1 < c) << endl;
}
```
***
## Бонус: как задавать для своего типа литерал

```cpp
# include <iostream>
# include <assert.h>

using namespace std;

unsigned long long operator "" _b(const char* str)
{
    size_t size = strlen(str);

    unsigned long long result = 0;
    for (size_t i = 0; i < size; ++i)
    {
        assert(str[i] == '1' || str[i] == '0');
        (result <<= 1) |= str[i] - '0';
    }

    return result;
}

double operator"" _kg(long double val)
{
    return val;
}

int main()
{
    cout << 101100_b << endl;
    cout << 76.3_kg << endl;
}
```