# 1.14. Шаблоны типов. Шаблоны классов. Полная или частичная специализация шаблонов классов. Параметры шаблонов задаваемых по умолчанию. Шаблоны с переменным числом параметров. Пространства имен.

## Шаблоны типов  

Про именное соответствие.

```cpp
typedef int (*cmp_t)(double, double); // cmp_t не есть тип, это имя типа. 
```

В С++ появилась возможность не просто определять имя типа, а тип.

```cpp
using cmp_t = int (*)(double, double); // А вот это уже другой тип.

template <typename T>
using cmp_t = int (*)(double T&, double T&); // Шаблон типа

...

cmp_t<double> pf = compare;
```

## Шаблоны классов

```cpp
template <typename T>
class array
{
    T *arr;
    size_t count;
public:
    Array(const Array &);
    Array(Array &&) noexcept;
    
    template<typename U>
    Array(Array<U> &&); // для такого метода будет всё аналогично шаблонной функции
    size_t size();
}

template <typename T>
size_t Array<T>::size() {return count;} // T пишем, поскольку для методов шаблонного класса можно сделать специализацию
```

Класс шаблонный, и все методы будут шаблонными, то есть они будут поддерживать шаблон класса, определение параметров будет на этапе, когда определяется тип. Например `Array<int>`, и методы будут создаваться только для этого типа. Здесь не будет сворачивание ссылок, поэтому может спокойно определить тип. Однако может быть в шаблонном классе шаблонный метод.

## Полная или частичная специализация шаблонов классов.

Классы, которые создаются по шаблону они ничем между собой не связаны. Специализация может содержать другие методы. 

Пример полной специализации класса и методов шаблона
```cpp
# include <iostream>

using namespace std;

template <typename Type>
class A
{
public:
A() { cout << "constructor of template A;" << endl; }
void f() { cout << "metod f of template A;" << endl; }
};

template <>
void A<int>::f() { cout << "specialization of metod f of template A;" << endl; }

template <>
class A<float>
{
public:
A() { cout << "specialization constructor template A;" << endl; }
void f() { cout << "metod f specialization template A;" << endl; }
void g() { cout << "metod g specialization template A;" << endl; }
};
```

## Шаблоны с переменным числом параметров.

Можно задавать вариативные шаблоны (с разным количеством параметров). `template <typename... Ts>`. Такой подход позволяет передавать разное количество параметров для конструирования объектов. К тому же, в вариативный шаблон можно предать значения -> становится возможным что-то вычислять на этапе компиляции.

```cpp
# include <iostream>

using namespace std;

template <size_t...>
struct Sum {};

template <>
struct Sum<>
{
enum { value = 0 };
};

template <size_t val, size_t... args>
struct Sum<val, args...>
{
enum { value = val + Sum<args...>::value };
};

int main()
{
cout << Sum<1, 2, 3, 4>::value << endl;
}
```

На шаблоны с переменным числом параметров можно реализовывать кортеж. Как альтернативу можно использовать структуру, но могут быть проблемы. 

Когда необходимо вернуть несколько параметров из метода, и сколько неизвестно, какого они типа -> создаём кортеж и его возвращаем.

## Пространства имен.

Есть несколько файлов, в разных файлов могут быть функции/классы с одинаковыми именами. Когда собираем это всё вместе, то может возникнуть конфликт имён. 

Пространство имён решает проблемы неоднозначности.

```
namespace <имя>
{
}
```

Всё, что задано внутри пространства имён можно получать доступ только через имя `<имя>::`. Поэтому классы следует заключать в пространства имён, желательно там, где несколько классов.

Однако каждый раз писать так имя не очень удобно, поэтому можно определить, что вы работаете с этим пространством имён, и уже не писать это имя. А если возникает конфликт, то нужно явно указывать имя пространства имён.

`using namespace <name>`
