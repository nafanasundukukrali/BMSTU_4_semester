# 1.8. Полиморфизм в С++. Виртуальные методы. Чисто виртуальные методы. Виртуальные и чисто виртуальные деструкторы. Понятие абстрактного класса. Ошибки, возникающие при работе с указателем или ссылкой на базовый класс. Дружественные связи.

Есть класс A, содержащий функцию f. Создаём производный класс B, изменяющий реализацию метода f.

```cpp
A *p = new B(); // Указатель производного класса преобразовывается в указатель базового класса
p->f(); // Вызовется метод класса A, а хочется ведь B...
```
В языке С++ реализовывается **единичный полиморфизм**, то есть чёткая должна быть наследственность производных классов. Как он реализуется? Пришли к выводу, что на раннем связывании это реализовать невозможно (например, в ЯП С функция можно было вызвать по указатель - происходило раннее связывание, то есть конкретно по адресу вызывалась функция. В с++, если передать указатель трудно понять, метод какого объекта надо вызывать на этапе компиляции). Такую возможность на этапе выполнения программы дают таблицы для каждого класса, размещённые в памяти. Объект этого класса при создании держит указатель на таблицу класса, а таблица это совокупность указателей на методы, которые можно вызывать. Это динамически создаётся. Такие таблицы позже назвали виртуальными таблицами. Проблема: много памяти и долго. Это всё описание **динамического полиморфизма**. В современных языках решение за то, будет ли использован этот механизм переносится на пользователя. В языке c++ это происходит с помощью виртуальных методов класса.

**Статический полиморфизм** - решение что вызывать переносится на уровень компиляции. 

В полиморфном классе желательно или запретить копирование, или определить конструктор копирования с excplicit. 

## Виртуальные методы

```cpp
class A
{
public:
    virtual void f();
};
```

Если в классе определён хотя бы один виртуальный метод, то он становится полиморфным -> при создании объектов класса будет добавляться указатель на виртуальную таблицу данного класса. Один виртуальный метод подразумевает, что и все остальные виртуальны, поскольку нужно осуществлять подмену одного на другое.

```cpp
class B : public A
{
public:
    void f() override;
};
```

В классе B f тоже виртуальный, если сигнатура совпадает. 

Класс B виртуальный, однако если изменить просто f, то не будет видно, виртуальный он или нет, если посмотреть иерархию. В прицнипе можно писать слово virtual перед void f(), однако это даст только знание того, что класс виртуальный. С 11 стандарта появилось слово `override`, оно говорит о том, что **класс является полиморфным и метод подменяет метод какого-нибудь базового полиморфного класса**. Но компилятор не обязует это делать.

## Чисто виртуальные методы

У сущностей C и B общая схема использования, то их объединяем базовым классом A, причём этот базовый класс будет предоставлять интерфейс для работы с производными классами. Однако база даёт только интерфейс, больше у неё задач нет.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_6_1.png)

Объединяя сущности мы выделяем абстрактное понятие. Базовый класс должен быть абстрактным и только абстрактным, объекты которого создавать нельзя. Для того, чтобы класс был абстрактным, необходимо, чтобы в нём была хотя бы один чисто виртуальный метод.

```cpp
class A
{
public:
    virtual void f() = 0; // реализовывать этот метод не надо, класс чисто виртуальный, объекты класса создавать нельзя.
};
```

Производные классы должны подменить этот метод. Если они не реализуют этот метод, то они будут тоже абстрактными.

Виртуальные методы нельзя вызывать в конструкторах и деструкторах, поскольку можно попасть на ситуацию, когда объекта ещё нет или уже нет.

## Виртуальные и чисто виртуальные деструкторы.

```cpp
{
A *p = new B(); 
p->f(); 
delete p;
}
```

Исходя из выше указанного примера, необходимо, чтобы уничтожался объект класса B, однако будет вызван деструктор класса A. Поэтому, при создании полиморфного класса всегда необходимо добавлять виртуальный деструктор.

```cpp
class A
{
public:
    virtual ~A() = default;
};
```

Деструктор может быть чисто виртуальным, но его надо реализовывать вне класса. Такой подход даёт возможность не за счёт методов, а за счёт деструктора сделать класс абстрактным.

```cpp
class A
{
public:
    virtual void f() = 0;
    virtual ~A() = 0;
};

A::~A() = default;
```

## Ошибки, возникающие при работе с указателем или ссылкой на базовый класс.

1. Пусть классы А и В находят на одной ветви иерархии.

```cpp
A *pa = 0;
B *pb = 0;

if (pa == pb) //  Ответ будет неоднозначный: если B произведено от A == true, а если подобъект по другому адресу внутри объекта, то произойдёт приведение указатель производного к базовому, и тогда ответ не предсказуемый.
...
```
2. Есть функция void f(A obj).
```cpp
B obj;
A &al = obj;
f(al); // Вызывается конструктор копирования для класса А, а работаем там с объектами класса А, вызываем его методы.
```
3. 
```cpp
A &index(A *arr, int t) // А сюда может быть передан указатель любого производного класса
{
return arr[t];
}
...

B arr = new B[10];
A obj = index(arr, 2); // Неявное приведение типа. Проблема работы с массивом объектов.
```

## Дружественные связи.

Дружба даёт доступ ко всем членам объектам другого класса. Для этого в другом классе прописываем модификатор friend. Дружба односторонняя. 

В современных языках от дружбы отказались, поскольку на любой метод класса накладывается задача обеспечения целостности объекта. Друг не может выполнить эту задачу. 

Друзей можно создавать для объектов, в которых члены данные не связаны между собой. 

Дружба не транзитивна (то есть, сын моего друга мне не друг) и не наследуется. Однако, если защищённые члены класса виртуальны, то друг будет иметь доступ к этим методам в производным классам.

#### Что может быть другом?

* Внешняя функция
* Метод, причём мб виртуальный метод
* Класс

```cpp
class C
{
    friend void f(C &);
    friend void A::g(); // Только 1 метод класса имеет доступ к членам класса. Меньше зависимости по данным.
    friend class B; // Все методы класса имеют доступ к членам
};
```