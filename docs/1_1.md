# 1.1. Структура программы на языках С и С++. Функции С и С++. Перегрузка функций в С++. Параметры функций по умолчанию.

## Структура программы на языках С и С++.

* Многофайловая организация программы. Программа состоит из набора файлов, которые включают в себя объявления и определения. Есть абстракция по типам и есть абстракция по данным.
1. Абстракция по данным - типа данных, переменная, константа. Данные абстракции можно объявлять или определять. ОбЪявление - информация для компилятора. Определение связано с выделением памяти. Объявлять можно много, определять один. 
2. Абстракция по действию - функция. Можно опять же её определять или определять.

* Выполнение программы начинается с функции с именем main, один файл реализации **должен содержать её**. Выполнение в общем случае может начаться с любой ф-ции и закончиться в любой. Есть приоритеты выполнения, их 256. 0-63 - библиотечные функции. Например, предварительно выполняются функции, работающие с разрешающими экрана -> сначала они выполнятся как из библиотеки, уже потом main.
* По действию абстракция - все функции внешние по отношению друг к другу (а в си мб вложенные функции, в си++ нет). Любая функция может вызвать любую другую функцию. В языке си++ функция main не может вызывать саму себя.
* Используется раздельная компиляция, правило - прежде чем что-то использовать нужно что-то объявить или определить. Для удобства создаются header-файлы, туда выносятся объявления. Все файлы (кроме с main) идут парами. 

Пример-картиночка-описание: есть файл с функцией main - main.cpp, есть файл f.cpp, его хотим подключить, в пару ставится f.h (на этапе препроцессирования подключается как к f.cpp, так и к main.cpp). Пережиток, поскольку в 69 люди использовали пакеты, и за счёт директив препроцессора формировали пакет. После препроцессирования идёт компиляция, получаем объектные файлы main.obj и f.obj. Далее надо собрать программу, есть линковщик. В принципе в средах есть понятие проект, используя его линковщик собирает программу, на выходе 
исполняемый файл. 

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_1_1.png)

Что выносим в заголовочный файл:
1. Объявление переменных (она должна быть где-то определена). Глобальное данное.
2. Объявление функции. За ним может ничего не стоять.
3. Константы **времени компиляции**

> Загадка Шрёдингера. Есть `const int c = 2;`, а есть `int i = 3; const int ci = i;`. Как к ним будет подходить компилятор? Первая константа времени компиляции, вторая константа времени выполнения. Первую он, как правило, везде где встретит вместо c будет подставлять значение. Как целостного данного этой константы нет. А второе - целостное данное, подставить в код нельзя, идентифицировано - можно взять адрес.

4. Определение типов. А почему? Потому что высокоуровневая абстракция, предобрабатывается компилятором.

Пример-картиночка-описание: Есть две пары. Хедеры подключаем к файлам реализации (потому что там определение типов). А если g.h используется в f.cpp и main.cpp. Куда подключать? Если подключить к заголовочному, то, напоминание, в раздельной компиляции происходит перекомпиляция только тех файлов, в которые были внесены изменения. Вот поменяется g.hh -> f.h меняется -> main.cpp тоже будет считаться, что поменялся -> ловинная перекомпиляция всего. Тогда подключаем к файлу реализации? Не всё так просто, поскольку заголовочный файл - информационый -> нам неудобно будет читать, получим дикий список того, чего нет. Итого, на этапе разработки подключаем к файлам реализации, в заголочном комментируем, на этапе релиза - к заголовочным.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_1_2.png)

Пример-картиночка-описание: Проблема. Если так сделать, то добро пожаловать во множественное определение. Что делать? Условное включение. Рассказ про защиту заголовка. Если речь о всём файле -> #pragma once

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_1_3.png)

Нюанс. Общую часть можно выносить в отдельный хедер-файл. Таким файлам может не соответствовать файл-реализация. Подключается к обоим файлам.

## Функции С и С++. Перегрузка функций в С++.

В c++ можно создавать функции с одним и тем же именем, но разными параметрами - **перегрузка функций**. 

На перегрузку функции влияет:
* Разное количество принимаемых параметров.
* Разный тип переменных.
* const значение функции/метода. Если объект константный, то будет вызываться const метод, иначе не const. 

> Примечание о том, что значит модификатор const у метода. Константный метод - это метод, который гарантирует, что не будет изменять объект или вызывать неконстантные методы класса (поскольку они могут изменить объект). Соответственно, для константных объектов нельзя вызывать неконстантные методы.

```cpp
//  Пример функции возведения в квадрат
int sqr(int x);  // для целых
double sqr(double x); // для дробных
int sqr(const int x) const; // для const  целых 
```

## Параметры по умолчанию 

В Си++ один или несколько аргументов функции могут задаваться по умолчанию. Для каждого параметра значение по умолчанию можно указать не более одного раза, но каждое последующее объявление функции, а также определение функции может назначать параметрам значения по умолчанию. Параметры по умолчанию должны быть последними в списке параметров. Эта хитрость решение проблемы количества параметров функции (их не более 3х). Значение параметров по умолчанию вычисляется на этапе компиляции. Устанавливаем значение при объявлении, если нет объявления - при определении. 

`void sort(double *arr, int count, int key = 0);`

```cpp
int func(int& ref, int a = 1, int b = 3)  { cout << "lvalue - " << ref << endl; return ++ref; } 
int func(int& ref, double c = 3) { cout << "rvalue - " << ref << endl; return ++ref; } // А это неоднозначность!
```