# 1.17. Приведение типа в С++: static_cast, dynamic_cast, const_cast, reinterpret_cast. Контейнерные классы и итераторы. Требования к контейнерам и итераторам. Категории итераторов. Операции над итераторами. Цикл for для работы с контейнерными объектами.

## Приведение типа в С++: static_cast, dynamic_cast, const_cast, reinterpret_cast. 

Выделено несколько вариантов приведения типов - несколько кастов. Любое неявное приведение - это плохо.

В языке С++ кроме простых типов на неявное приведение влияют конструкторы с параметром и операторы приведения типов. Поскольку все они explicit, то остаётся или явно привести тип, или использовать соответствующий каст.

#### static_cast 

Шаблон. Выполняется на этапе компиляции. Каст простых типов int -> double, для наших типов вызов оператора приведения типа и вызов конструктора, принимающих 1 параметр, даже если написано explicit, они будут вызваны. `A obj = static_cast<A>(B);` Его можно использовать для приведения типа по иерархии классов. Он проверяет только, находится ли класс, к которому мы приводим, в этой иерархии или нет. Если по этой, то приводит. pa можно к С и к D. А вот на прямую от pb к pd нельзя. А вообще можно pb к void*, и тут вообще можно к указателю любого класса.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_17_2.png)

static_cast не срезает const и не срезает volatile.

Напоминание от Зоткина А ЧТО ТАКОЕ VOLATILE)? 

volatile  — ключевое слово языков C/C++, которое информирует компилятор о том, что значение переменной может меняться из вне и что компилятор не будет оптимизировать эту переменную.

Ну давайте начнем, к примеру имеем простой массив(правда не с простым размером), в цикле с которым выполняем какое-либо действие:

```cpp
int ar[1024];
for(size_t i = 0; i < 1024; i++)
{
    ar[i] = ...;
}
```

Самая затратная операция в этом примере не присваивание ячейке массива какого-либо значения и не инкремент счетчика, а именно операция сравнения, поэтому компилятор оптимизирует это примерно вот так:

```
int ar[1024];
for(size_t i = 0; i < 1024 / 4; i += 4)
{
    ar[i] = ...;
    ar[i + 1] = ...;
    ar[i + 2] = ...;
    ar[i + 3] = ...;
}
```

А с volatile такого не будет.

#### const_cast

Срезает const и срезает volatile как с ссылки, так и с указателя, правда не всегда - срежет только с константы времени выполнения. Создаётся новый объект, новый указатель и новая ссылка. Или можно, наоборот установить const. 

#### dynamic_cast

Проблему приведения от базового класса к производному. По этому причине добавили ещё один шаблон. Используется на этапе выполнения. Тяжёлый. 

Если идёт приведение, от производного к базовому, то всё нормально, если не базовый возвращает nullptr. Если работа со ссылками, то кидается исключение bad_cast. Приведение от базового к производному, но только в том случае, если базовый полиморфный, но в таком случае можно приводить в низ по иерархии до того момента, пока не дойду до реального объекта.

Этот каст позволяет прыгать от одной базы к другой.

`dynamic_cast<void *>` - ...и ввели указатель на родителя, но в данном случае будет возвращён указатель на реальный объект. Нахрена? А никто не знает, надо.

#### reiterpret_cast

Идея: может любую ссылку, объект привести к указателю на что угодно. Единственное, не снимает ни const, ни volatile. 

Короче, весь мир - иллюзия, ограничения на поля доступа тоже, потому что взяли объект с этим кастом и начали чудить. Но не работает с простыми типами, типа double, int.

Как определить адрес объекта, если & перегружен.

```cpp
# include <iostream>

using namespace std;

class A
{
private:
    int a;

public:
    A* operator &() const noexcept = delete;
};

namespace my
{
    template<typename T>
    T* addressof(T& v)
    {
        return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const char&>(v)));
    }
}

int main()
{
    A obj;

//    cout << &obj << endl; // Error!

    hex(cout);
    cout << my::addressof<A>(obj) << endl;
}
```

## Контейнерные классы и итераторы.

Контейнерные классы содержат в себе другие объекты. Раньше у всех контейнеров был одинаковый интерфейс, со временем пришли к выводу, что это неудобно. Как работать с разными контейнерами?

Идея: выносим текущий указатель в отдельную структуру или класс. Если нужно несколько текущих указателей, то их можно создавать как объекты класса. То, что вынесли отдельно, назвали итераторами. Итераторы позволят унифицировать работу с контейнером, задают логику просмотра содержимого контейнера, алгоритмы реализуются уже на итераторах.

Что даёт такой подход:
1. Вынос указателей позволяет абстрагироваться от структуры контейнера. 
2. Снимаются ограничения на интерфейс контейнера, за исключением:
* Нужны итераторы на начало begin() и терминатор, возникающий после конца итератора end(). Например, в массиве это что-то после конца массива.
* Если необходимо, чтобы итераторы на изменяли содержимое контейнера, то добавляют cbegin(), cend() как требования к контейнеру, если контейнер не константный, которые возвращают константный итератор.
* Если необходимо, чтобы в контейнере нужно было бы проходить в обратном, то добавляют rbegin(), rend(), crbegin(), crend().

## Требования к контейнерам и итераторам

### Требования к контейнеру 

Накладываются требования на организацию. В нём необходимо определить алиасы и определённые методы. Какие алиасы? 
* using value_type = T; // алиас типа.
* using iterator = Interator<T>; // поскольку бегин енд возвращают итератор
* using const_iterator = ConstIterator<T> ; // cbegin cend
* using size_type = size_t;

Если их определить, то современные библиотеки проверяются наличие этих алиасов.

### Требования к итератору

* using iterator_category = output_iterator_tag // категория итератора
* using value_type = T; // какой тип будет итератор возвращать
* using pointer = T*; // итератор как хранитель - прозрачная оболочка. Нужны операторы -> *
* using reference = T&; 
* using difference_type = size_t; // тип расстояния.

## Категории итераторов

Категории итераторов возникли, поскольку есть различные способы определения логики просмотра содержимого.

Задаются они тегами. По существу структуры. Под каждую категорию есть стандартный концепт. Например output_iterator.

#### output_iterator_tag

Итератор позволяет только запись данных в контейнер. По большому счёте не можем даже итерироваться в нём. Пример - ostream итератор. В потом отправляем данные с помощью итераторов.

#### input_iterator_tag

Итератор позволяет только читать. Он на те контейнеры, которые не гарантирует однозначность при нескольких проходов данных. Например буффер, он постоянно меняется. 

#### forward_iterator_tag

Однонаправленный итератор, проходим от начала до конца, однозначность ответа,, можем изменять данные.

#### bidirectional_iterator_tag

Итератор можно перемещать в обе стороны. 

#### random_iterator_tag

Итератор позволяет получить произвольный доступ.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_17_1.png)

## Цикл for для работы с контейнерными объектами.

Начиная с 11 стандарта для работы с итератором добавился цикл for each. Если в классе нет алиасов, но есть begin(), end(), *, ++i, то можно использовать for each. Да даже если нет в контейнере, то можно использовать std::begin, std::end.

```cpp
for (Iter it = v.begin(), it != v.end(); i++)
    cout << *it;

for (auto elem: v)
    cout << elem;
```

Пример итератора.

```cpp
# include <iostream>
# include <memory>
# include <iterator>
# include <initializer_list>

using namespace std;

template <typename Type>
class Iterator;

template <typename Type>
class ConstIterator;

class BaseArray
{
public:
using size_type = size_t;

BaseArray(size_t sz = 0) { count = shared_ptr<size_t>(new size_t(sz)); }
virtual ~BaseArray() = 0;

size_t size() const noexcept { return bool(count) ? *count : 0; }
explicit operator bool() const noexcept { return size(); }

protected:
shared_ptr<size_t> count;
};

BaseArray::~BaseArray() = default;

template <typename Type>
class Array final : public BaseArray
{
public:
using value_type = Type;
using iterator = Iterator<Type>;
using const_iterator = ConstIterator<Type>;

Array(initializer_list<Type> lt);
~Array() override = default;

iterator begin() const noexcept { return Iterator<Type>(arr, count); }
iterator end() const noexcept { return Iterator<Type>(arr, count, *count); }

private:
shared_ptr<Type[]> arr{ nullptr };
};

template <typename Type>
class Iterator
{
friend class Array<Type>;

public:
using iterator_category = forward_iterator_tag;

using value_type = Type;
using difference_type = ptrdiff_t;
using pointer = Type*;
using reference = Type&;

public:
Iterator(const Iterator& it) = default;

bool operator ==(Iterator const& other) const;

reference operator*();
const reference operator*() const;
pointer operator->();
const pointer operator->() const;
operator bool() const;

Iterator& operator++();
Iterator operator++(int);

private:
Iterator(const shared_ptr<Type[]>& a, const shared_ptr<size_t>& c, size_t ind = 0)
: arr(a), count(c), index(ind) {}

private:
weak_ptr<Type[]> arr;
weak_ptr<size_t> count;
size_t index = 0;
};

#pragma region Method Array
template <typename Type>
Array<Type>::Array(initializer_list<Type> lt) : BaseArray(lt.size())
{
if (!count) return;

arr = make_shared<Type[]>(*count);


for (size_t i = 0; auto elem : lt)
arr[i++] = elem;
}

#pragma endregion

#pragma region Methods Iterator
template <typename Type>
bool Iterator<Type>::operator ==(Iterator const& other) const { return index == other.index; }

template <typename Type>
Iterator<Type>::reference Iterator<Type>::operator *()
{
shared_ptr<Type[]> a(arr);

return a[index];
}

template <typename Type>
Iterator<Type>& Iterator<Type>::operator ++()
{
shared_ptr<size_t> n(count);
if (index < *n)
index++;

return *this;
}

template <typename Type>
Iterator<Type> Iterator<Type>::operator ++(int)
{
Iterator<Type> it(*this);

++(*this);

return it;
}

#pragma endregion

template <typename Type>
concept Container = requires(Type t)
{
typename Type::value_type;
typename Type::size_type;
typename Type::iterator;
typename Type::const_iterator;

{ t.size() } noexcept -> same_as<typename Type::size_type>;
{ t.end() } noexcept -> same_as<typename Type::iterator>;
{ t.begin() } noexcept -> same_as<typename Type::iterator>;
};

ostream& operator <<(ostream & os, const Container auto& container)
{
for (auto elem : container)
cout << elem << " ";

return os;
}

int main()
{
Array<int> arr{ 1, 2, 3, 4, 5 };

cout << "Count = " << distance(arr.begin(), arr.end()) << endl;

cout << "Array: " << arr << endl;
}
```