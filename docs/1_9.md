# 1.9. Обработка исключительных ситуаций в С++. Решение проблем структурного программирования. Блоки try и catch. Блоки try и catch методов и конструкторов. Безопасный код относительно исключений. Обертывание исключения в exception_ptr. Задачи которые может решать исключение. Проблемы с динамической памятью при обработке исключительных ситуаций.

> Нужно понимать, где находится водораздел, где сверху кидаем исключения, а снизу изменяет объект.

## Решение проблем структурного программирования

Недостатки обработки ошибок в структурном программировании:
* Если где-то возникает ошибка в коде, мы вынуждены "протащить" ее через все
уровни абстракции/иерархии до того места, пока мы не сможем обработать эту
ошибку.
* Весь код насыщен непрерывными проверками. Обработка ошибки совмещена
вместе с кодом.

Идея: не протаскивать ошибку через весь код, а её пробросить. 

Каждая функция рассматривается как отдельная задача. Когда идёт речи об обработке ошибки компилятор добавляет кучу кода, при пробросе ошибку необходимо поймать. Речь идёт, что по списку вызовов проходит до того уровня, где ловится ошибка.

Включение этого механизма отводится программисту, поскольку этот механизм требует больших расходов: размер кода, время выполнения.

В библиотеке есть класс std::exception, этот класс содержит виртуальный метод what.  Есть стандартные классы ошибок, например std::bad_alloc. На основе этого класса можно создавать свои классы ошибок.

```cpp
class ExceptionArray : public std::exception
{
protected:
static const size_t sizebuff = 128;
char errormsg[sizebuff]{};

public:
ExceptionArray() noexcept = default;
ExceptionArray(const char* msg) noexcept
{
strcpy_s(errormsg, sizebuff, msg);
}
~ExceptionArray() override {}

const char* what() const noexcept override { return errormsg; }
};
```

Каждая исключительная ситуация - должен быть отдельный класс. Такой подход даёт возможность модификации.

## Задачи, которые может решать исключение.
1. Не нужно протаскивать ошибку
2. Отделяем обработку исключений в отдельный блок
3. Легко модифицировать, добавляя производные классы в иерархию.

## Блоки try и catch. Блоки try и catch методов и конструкторов.

Блок try позволяет взять под контроль генерирование исключительных ситуаций: будет проброс из этого места на блок, который сможет поймать (catch), причём таких блоков может быть много.

```cpp
try {
    ...
    throw <об>;
} catch (<тип> &<об>) {
}
```

Здесь нет приведения типов, т.е. жесткая типизация, за исключением перевода ссылки/указателя с базового класса на ссылку/указатель производного. Если на этом уровне ни один из catch не перехватил этот объект, то это передается на более высокий уровень. Ошибка может никем не перехватиться, в этом случае программа "падает". По этому причине в верхнюю обёртку исключений добавляют `catch(...)`, который может отловить любое исключение, да с этой информацией, кроме как вывести сообщение об ошибке ничего нельзя сделать, но свернется также стек, а это лучше, чем ничего. 

Из кода убирается постоянная обработка исключения, это выделяется в отдельный код (блок).

#### В блоке catch исключение можно пробросить дальше. Его будет ловить объемлющий блок.

```cpp
catch(...)
{
throw;
}
```

#### Блок try может быть у меня и у функции.

```cpp
void f(int v) try
{
}
catch (...)
{
}
```
Происходит исключительная ситуация -> в этом блоке можно работать с тем, что есть в самой функции. Например с параметром. Стек для такой функции будет отчищен только после того, как выйдем из блока.

```cpp
void A::f(int v) try
{
    if (v < 0)  throw std::runtime_error("error in method f!");
}
catch (const std::runtime_error& err)
{
    cout << err.what() << " v = " << v << endl;
}
```

#### try также удобно использовать с циклом. 

```cpp
for (int i = -1; i < 3; i++) try
    {
        cout << i + 1 << endl;
        Array ar(i);

        ar[i - 2];
    }
    catch (const ErrorArray& err)
    {
        cout << err.what() << endl;
    }
    catch (const ErrorBase& err)
    {
        cout << err.what() << endl;
    }
```

## Блоки try и конструкторов.

Блоки try могут быть как в теле конструктора, так и в разделе инициализации.

```cpp
Array::Array(int q) try : mas(new double[q]), cnt(q)
{}
catch (const std::bad_alloc& exc)
{
cout << exc.what() << endl;

throw ErrorArrayAlloc();
}
```

Требования:
1. В конструкторе нужно перехватить исключение (должен быть блок catch).
2. Этот перехват должен кинуть исключение дальше.

## Безопасный код относительно исключений.

```cpp
try
{
A *p = new B;
p->f(); // тут вызвалась ошибка. Свернулся стек.
delete p; // А это лежит в ДП, уничтожено не будет.
}
```

1. При прокидывании исключения необходимо, чтобы не нарушилась целостность объекта, из метода которого пробрасывается исключение. Утечки памяти быть не должно.

2. В КЛАССЕ КОНСТРУКТОР КОПИРОВАНИЯ, БАЗОВЫЙ, ОПЕРАТОР КОПИРОВАНИЯ НЕ ДОЛЖНЫ ОБРАБАТЫВАТЬ ИСКЛЮЧЕНИЯ. Для любого метода, можно поставить модификатор noexcept, это обещание компилятору, что мы не будем обрабатывать исключительные ситуации. Если ситуация исключительная возникает -> выполнение программы завершается, вызывается специальный метод terminate, задача которого очистить стек. Рекомендуется его указывать по тому причине, что компилятор также начинает быстрее работать.

3. Любой деструктор по умолчанию не бросает исключения. А если всё-таки бросает исключение, то будет бесконечный цикл (а он ещё в цикл заворачиваем, а он опять ещё в цикле...). noexcept ставить смысла нет.

## Обертывание исключения в exception_ptr

Наша задача обеспечить водораздел, где кидаем исключения, а где изменяем сам объект. А если это не удаётся? Можно сделать так: сделать область в начале, где кидаются исключения, затем область, где выполняется изменение объекта, и, наконец, область, где вновь кидаются исключения. Можно исключения не кинуть сейчас, а обернуть, и кинуть тогда, когда это станет возможным. 

```cpp
void do_raise()
{
    throw std::runtime_error("Exception!");
}

exception_ptr get_excption()
{
    try
    {
        do_raise();
    }
    catch (...)
    {
        return current_exception();
    }
    return nullptr;
}

int main()
{
    try
    {
        exception_ptr ex = get_excption();

        rethrow_exception(ex);
    }
    catch (const std::runtime_error& err)
    {
        cout << err.what() << endl;
    }
}
```

## Проблемы с динамической памятью при обработке исключительных ситуаций.

Проблема: когда ошибка будет поймана, то происходит сворачивание стека до места, где она была поймана -> всё, что было на стеке уничтожается, но не уничтожается то, что лежит в динамической памяти.