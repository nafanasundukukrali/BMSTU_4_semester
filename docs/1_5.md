# 1.5. Конструкторы копирования и переноса. Модификатор explicit. Удаление конструктора и default конструктор. Делегирующие и унаследованные конструкторы.
***
Операторы языка new|delete - создание объекта и возврат типизированного указателя. Куча.
***

## Конструктор копирования и переноса

Конструктор должен быть явно определён, поскольку не явно определённый конструктор будет производить поверхностное копирование. Тогда мб создана ситуация, когда есть два указателя на одну и ту же область памяти, например, и если посредством одной удалить память, то будет висячий указатель (типа того?).

```cpp
class Array
{
private:
   double *arr;
   int count;
public:
   Array(int c): count(c) {
      arr = new double[c]{}; // чтобы была инициализация чем-то - фигурные скобки по 20-му стандарту
   }
};
```

## default
Если в классе определён хотя бы один конструктор, то конструктор по умолчанию не создаётся, его нужно определять явно. А если не хочется явно?

`Array() = default;`

Напомню, конструктор копирования должен быть определён явно. Принимает константную ссылку.
```cpp
Array(const Array &a);
```

Я воздал объект в методе и хочу вернуть этот объект. Но объект локальный, поэтому возвращаю по значению.

```cpp
Array::Array(const Array& ar) : count(ar.count)
{
    arr = new double[count];

    for (int i = 0; i < count; ++i)
        arr[i] = ar.arr[i];
}

static Array minus(Array a)
...
Array lol = Array::minus(basa);
```
Вызовется конструктор копирования при определении lol. При этом массив с локальным временем жизни перестанет существовать после копирования. В массиве копирование может быть очень дорогой операцией. Поэтому определяются конструктор перемещения. Выглядит он примерно так:

```cpp
Array::Array(Array&& ar) noexcept : count(ar.count) 
{
    arr = ar.arr;

    ar.arr = nullptr; // В конструктор передаётся временный объект. Будет вызван деструктор ar -> arr будет висящим указателем.
    // nullptr - объект.
}
```

> А кто такой наш массив, который отомрёт после копирования? Это не область памяти -> rvalue.

**КОНСТРУКТОР ПЕРЕНОСА НЕ СОЗДАЁТСЯ ПО УМОЛЧАНИЮ!**

Внимание, мировое зло, но тут тоже вызывается конструктор переноса:

```cpp
Array mas(0);
Array mas1(std::move(mas));
```

Основная задача конструктора переноса: при передаче временных объектов в методе и при возврате по значению объектов.

## delete

Нужно запретить копирование полностью. Раньше ради этого делали метод private. С 20-го стандарта есть оператор `Array(const Array &array) = delete`.

## Модификатор Explicit

Объекты должны передаваться по ссылке. Для того, чтобы запретить неявный вызов конструктора копирования есть модификатор explicit. Explicit с delete при конструкторе копирования пользоваться нельзя.

Правило: все конструкторы, которые принимают 1 параметр должны быть с модификатором explicit. Зачем? Чтобы не было случайного приведения типа. `explicit Array(const Array &arr);`.

# Делегирующие и унаследованные конструкторы.

Функции можно перегружать по принципу, вызвана ли она для временного объекта или нет.

```cpp
class A
{
public:
   int f() const &; // 1
   int f() &&; // 2
};

...

A obj;
obj.f() // 1
std::move(obj).f(); // 2
A().f(); // Специальный объект для вызова метода, будет уничтожен после вызова метода по 2 перегрузке.
```

Можно в другом конструкторе вызвать конструктор.

```cpp
class A
{
public:
   A(int);
   A(int, double): A(1);
};
```

Важно: серия 5 констуркторов не наследуются, поскольку производное понятие расширяет базовый класс. А если хочется их пронаследовать?

```cpp
class B: public A
{
private
    d;
public:
    B(double d);
    using A::A;
};
```

Если с такими же параметрами определю конструктор в B, то это конструктор подменит такой же конструктор из базового.