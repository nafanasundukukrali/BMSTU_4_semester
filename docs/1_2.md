# 1.2. Ссылки. lvalue и rvalue ссылки. Передача параметров в функции по ссылке. Автоматическое выведение типа.

## Ссылки

Механизмы возврата из функций:

1. По значению.
2. Через указатель.

Как предаём структуру? По указателю. А если по значению? Вся копируется в стек (время + память). Проблема с указателем? Можем проверить только на null, и всё. 

Ссылка (alias, reference) - тот же указатель по коду в ассемблерном коде, но есть контроль. Ссылка должна быть инициализирована, однозначно указывает на область память. Это псевдоним, ещё одно имя одного данного. **Не является типом данных!**

```cpp
int i;
int &ai = i;
ai = 2; // i = 2;
```

```cpp
void swap(double &d1, double &d2)
{
double buf = d1; d1 = d2; d2 = d1;
}
```

Используется также возврат по ссылке. 

```cpp
double &maxF(double *ar, int count)
{
   double amax = *ar;
   ...
   return amax; // Мы возвращаем ссылку на локальную переменную, велком ту висящую ссылку.
}
```

## l-value & r-value

`<lvalue> = <rvalue> `

То, что стоит слева, должно ассоциироваться с ячейкой памяти, а вот справа не обязательно.

int & - левая ссылка - ссылка на индентифицированное выражение.
int && - правая ссылка - ссылка на НЕ индентифицированное выражение.

```cpp
int i  = 0;
cont int ci = 0;
int &lv1 = i;
const int &clv1 = ci;
int &lv2 = i + 1; // Так нельзя, так как не указывает на область памяти
const int &lv2 = i + 1; // А так можно. Вычисляется значение, выдлсяется память, туда значение. Пока все ссылки не умрут 
                       // - память захвачена. можно взять адрес.
```

По поводу правой.

```cpp
int &&rv1 = i; // Ошибка, ссылка на инициализированную область памяти.
int &&rv2 = i + 1; // Опять же выделение памяти, содержимое можно менять. 
++rv2;
int &&rv3 = rv2; // ВНИМАНИЕ. Оно ссылается на ячейку памяти. rv2 стала идентифицируемой -> ошибка
int &lv2 = rv2; // Ок
int &&rv4 = i + 0; // Это будет ссылка на копию i, не на i
int &&rb5 = (int)i; // Опять копия, опять ссылка на копию
```

А хотим ссылку правую на i...

```cpp
int &&rv6 = std::move(i); // Связали эту ссылку с областью памяти, где находится переменная i.
```

std::move используется для переноса.

```cpp
#include <iostream>

# include <iostream>

using namespace std;

int main()
{
    int i = 0;
    int&& rv1 = i + 0;
    int&& rv2 = std::move(i);
    int&& rv3 = (int)i;

    ++i;

    int&& rv4 = 5;
    ++rv4;

    cout << "rv1 = " << rv1 << "; rv2 = " << rv2 << "; rv3 = " << rv3 << endl;
    cout << "rv4 = " << rv4 << endl;
}
```
Итого:

```
rv1 = 0; rv2 = 1; rv3 = 0
rv4 = 6
```
## Передача параметров в функции по ссылке. 

```cpp
# include <iostream>

using namespace std;

int func(int& ref)  { cout << "lvalue - " << ref << endl; return ++ref; }
int func(int&& ref) { cout << "rvalue - " << ref << endl; return ++ref; }

int main()
{
    int i = 0;

    func(i); // левая ссылка, i = 1 в итоге
    func(std::move(i)); // правая ссылка, но ссылка указывает на область памяти с i. i = 2 в итоге
    func(i + 1); // правая ссылка, выведет 3, но i останется тот же
    func(func(i)); // Сначала будет левая ссылка, i = 3, потом будет как правая ссылка, i не поменяется

    cout << "i = " << i << endl;
}
```
```
lvalue - 0
rvalue - 1
rvalue - 3
lvalue - 2
rvalue - 3
i = 3
```

Тест на вшивость:

```cpp
void func(int &i); // 1
void func(cont int &i); // 2
void func(int &&i); // 3
```
```cpp
int i;
const int c = i;
int &lv = i;
const int &clv = c;
int &&rv = i + 1;
```
```cpp
f(i); // 1
f(c); // 2
f(lv); // 1
f(clv); // 2
f(rv); // 1, потому что это уже инициализированная память)))
f(i + 2); // Подходят и 2, и 3, но более чёткий тип у 3. 
f(f(i)); // Внутри 1, снаружи 3
f(std::move(i)); // 3
```

ВНИМАНИЕ! Если 1 и 3 закомментировать, то все вызовы функций нормально работают.

## Автоматическое выведение типа.

А почему бы не определять тип по значению? Добавили модификатор auto.

`auto i = 2;`

i будет иметь конкретный тип. В  языке Си - структурное соответствие типов, а С++ - именное. То есть в С++ два одинаковых типа имеют разные имена - данные разных типов. 

> Кое-что, что мне показалось забавным

```cpp
# include <iostream>

int main()
{
    int i = 0;
    const int ci = 0;
    int& lv = i;
    const int& clv = ci;
    int&& rv = i + 1;

    // тип int&
    {
        auto&& refx1 = i;
        auto&& refx3 = lv;
        auto&& refx5 = rv;
    }
    
    // тип const int&
    {
        auto&& crefx2 = ci;
        auto&& crefx4 = clv;
    }
}
```