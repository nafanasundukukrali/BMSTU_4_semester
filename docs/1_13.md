# 1.13. Неявные шаблоны. Протаскивание типа передаваемого параметра через шаблон (шаблон std::forward). Определение типа с помощью decltype. decltype(auto). Специализация шаблонов функций.

## Неявный шаблон

При подстановки параметров происходит свёртывание ссылок, и в некоторых ситуациях убирается модификатор const при передачи параметров. 

Есть такой шаблон функции.

```cpp
template <typename T>
T f(T v) {return v;} // 1
template <typename T>
T f(T &v) {return v;} // 2
template <typename T>
T f(const T &v) {return v;} //3
...
int i;
int &i = i;
const int &b = 0;

f(i); // 1: Здесь происходит выведение типа, то есть передаётся параметр типа int, логично что T будет выведен как int. 
// 2: принимает как ссылка на тип. А раз ссылка, то не должно быть копирование int f<int>(int & v);
// 3: int f<int>(const int &v);
f(a); // 1: произойдёт срезание ссылки.
// 2: int f<int>(int & v)
// 3: int f<int>(const int &v);
f(b); // 1: вообще спилит и const заодно
// 2: int f<const int>(const int &v);
// 3: int f<const int>(const int &v);
```

А вот в двадцатом всё можно упростить в...

```cpp
auto f(auto v) {return v;};

int main()
{
    int i = 8;
    int &a = i;
    const int &b = 0;

    f(i);
    f(a);
    f(b);
}
```

А это называется **неявным шаблоном**. По нему то же будут выполняться те же действия, что и обычным шаблоном. 

## Протаскивание типа передаваемого параметра через шаблон (шаблон std::forward), сворачивание ссылок, определение типа с помощью decltype, decltype(auto).

```cpp
template <typename T>
T f(T && v);
```

Вот если конкретный тип, принимает по правой ссылке -> сможем предать только правое выражение. Однако передать здесь можно что угодно, но будет свёртывание ссылок.

Так, если & принимаем как &&, то результат сворачивается в &. А вот если передавать правую, то будет правая. 

```cpp
int i; // int &f<int&>(int & )
int &a = i; // int &f<int&>(int & )
const int &b = 0; // const int &f<const int&>(const int & )
f(move(a)); // тип будет выведен int, а принимать будет правую ссылку. А хочется получить int&& в конце...
```

Необходимо, чтобы возвращаемый тип как-то предопределялся. `auto f(T && v)`  не хорошо, поскольку он срезает все ссылки.

`auto f(T && v) -> decltype(v)` - происходит определение типа по выражению. В этом случае auto ничего говорит, подразумевается, что идёт определение типа по decltype(v). Иногда это вынуждено писать, например когда происходит объявление, а нужно определение auto по возвращаемому выражению. 

`decltype(auto) f(T && v);` - и вот в этом случае срезания ссылок не будет.

```cpp
template <typename T>
decltype(auto) f(T && v)
{
    return std::forward<T>(v); // У параметра v вернёт его исходный тип. Вот была правая ссылка и вернётся правая ссылка.
}
```

Тот же вариант с неявным шаблоном.

```cpp
decltype(auto) f(auto && v)
{
    return std::forward<decltype(v)>(v); 
}
```

## Специализация шаблонов

Для определённых типов тот шаблон, который задали, может не подходить. Более того, шаблон может быть пустой, а работа будет только со специализацией шаблона. У шаблона может быть несколько параметров, для шаблонов функций и методов возможна только полная специализация, то есть надо явно указать значения всех параметров. Для классов возможна частичная специализация. Специализации в коде определяются после шаблона.

```cpp
template<typename T>
void swap(T &s1, T &s2);

template<>
void swap(int &s1, int &s2); // Это всё ещё шаблон, не компилируется, проверка только на синтаксис.
```

Выбор происходит следующим образом: есть шаблоны, их специализации и перегруженные функции. Сначала он смотрит перегруженные функции. Если ни одна из перегруженных функций не подходит, то он начинает пытаться использовать специализации. Если ни одна из специализаций не подошла, пытается подставить в шаблоны. Предпочтение более специализированному шаблону. 

```cpp
template<typename T>
int f(T);
template<typename T>
int f(*T); 

...

int a;
f(&a); // более специализированный int f(*T);
```

А если нельзя выяснить, какой более специализированный, то компилятор падает.