# 1.4. Создание и уничтожение объектов в С++. Конструкторы и деструкторы. Раздел инициализации конструкторов. Способы создания объектов. Явный и неявный вызов конструкторов. Приведение типа.

## Создание и уничтожение объектов в С++

* Как и в языке Си, любое определение приводит к вызову конструктора. Замечание: если определять глобальное данное, то конструкторы выполняются до вызова функции main.
* Конструкторы отрабатывают в том порядке, в котором они появляются. Деструкторы отрабатывают в обратном порядке их создания по стеку. 
* Abort, exit ни в коем случае нельзя использовать в конструкторах и деструкторах! В деструкторе это приводит к бесконечной рекурсии.
* К созданию объекта так же приводит к new, delete - к деструктору. Они возвращают типизированный указатель (в отличие от void в C) на память в куче. 

## Конструкторы 

При создании объектов все члены должна быть проинициализированы. При создании объекта должна быть сразу проинициализирована. Для инициализации выделяют специальный метод - **конструктор**. Вызов этого метода может быть явным, так и не явным. 


По умолчанию создаются несколько конструкторов:
1. Конструктор без параметров.
2. Конструктор копирования (поверхностного).
3. Конструктор переноса.

## Что из себя представляет конструктор? Раздел инициализации

В c++ **конструктор** - это метод, который не имеет типа возврата и его имя должно совпадать с именем класса.

```
<имя класса>::<имя класса>([<параметры>]): [раздел инициализации]
{
   <тело конструктора>
}
```

Задача раздела инициализации - создание объекта. Он выполняется до создания объекта, самого объекта ещё нет.
1. Класс может быть производным от других классов, должны быть вызваны конструкторы баз.
2. Инициализация членов класса. Единственное место, где инициализируются константные члены объектов.

В разделе инициализации сначала вызываются конструкторы класса, а затем происходит инициализация членов объекта в том порядке, в котором они объявлены в классе. **Порядок инициализации в разделе инициализации ни на что не влияет.**

Тело конструктора выполняется, когда объект уже есть, работаем с указателем this.

```cpp
class A:
{
private:
   int a;
   const int b;
   staic int sc;
   static const int scd;
public:
   A(int i);
   static int g() {};
   int f() {};
}

A::A(int i): a(i), 
             b(i), // ТУТ И НАДО!
             sc(i) // Error,
             scd(i) // Error
{
a = i;
b = i; // Error
sc = i;
scd = i; // Error
}
```

## Способы создания объектов. Явный и неявный вызов конструкторов. Приведение типа.

Явно можно вызвать конструктор следующими способами:
```
<тип> <идентификатор> [(<параметры>)]; // A obj(). Это может быть воспринято компилятором как объявление функции без
                                       // параметров или вызов коснтруктора; приоритет у объявления функции. Поэтому появилось
<тип> <идентификатор> {[параметры]}; 
<тип> *<идентификатор> = new <тип>{(параметры)};
<тип> <идентификатор> = <тип>{(параметры)}; // Это используют редко.
```
Неявно:
```
<тип> <идентификатор> = <значение>;
<тип> <идентификатор> = {(параметры)};
```
### Проблемы неявного приведения типа

```cpp
class A
{
public:
    A(int);
    void f(A); 
};

...

f(10); // Это приведёт к неявному вызову конструктора.

...

A obj;
obj = 10;
```

**Любой конструктор надо рассматривать как оператор приведения типа (`<тип>(<выражение>)`).**

Одно из решение проблем неявного приведение типа - механизм запрета передачи типа в функцию используя механизм перегрузки с удалением.

```cpp
class Complex
{
    ...
    void set_Real(int r) { this->_re = r; }
    void set_Real(double) = delete;
...
};
...
e1.set_Real(1);	// '1', 1l, L'1' - Ok! 1ll, 1u, 1lu, 1.f, 1.l, "1" - Error!
```

## Деструктор

Тоже порождается по умолчанию. Функции: освобождение ресурсов, забоится о связях с другими объектами. Не имеет типа возврата. `~Array();` 
* Начинается с символа тильта
* Имя совпадает с именем класса
* Параметров не принимает

Деструктор можно вызывать явно.

***

## Конструкторы класса и деструктор: по умолчанию, при захвате ресурсов, какие нужно явно указывать

По умолчанию создаются
1. Конструктор по умолчанию
2. Конструктор копирования
3. Конструктор переноса

Если реализован хотя бы один конструктор, то конструктор по умолчанию не создаётся.

За уничтожение отвечает специальный метод  - деструктор.

### При динамическом выделении памяти необходимо явно определять

1. Деструктор
2. Конструктор копирования
3. Оператор присваивания с копированием
4. Конструктор переноса
5. Оператор присваивания с переносом