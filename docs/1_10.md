# 1.10. Перегрузка операторов в С++. Операторы .*, ->*. Правила перегрузки операторов. Перегрузка операторов =, () и [ ]. Перегрузка операторов ->, * и –>*.

Идея: вы создаёте свой тип, почему бы для него не определить набор операций. 

Идея перегрузки: задать новую операцию на основе существующего оператора. Почему не просто определить новый набор операций? Потому что для новой операции надо выбрать символ, её приоритет, порядок выполнения... В с++ такого нет.  Сохраняется приоритет оператора, количество операндов, порядок выполнения от исходного оператора. 

## Какие операторы не перегружаются?

`.` (доступ к члену), `.*` (доступ члена по указателю объекта), `::` (доступ к контексту), `:?` (а это не придумали как), `sizeof`, `typeid`.

## Операторы `.*` и `->*`

Есть функция `void f();`. Можно определить указатель на функцию. Этот указатель можно инициализировать. И используя этот указатель вызвать функцию.

```cpp
void (*pf) ();
pf = f;
pf();
```

А если эта функция - метод `void A::f()`? Метод объекта получает указатель this, который нужно каким-то образом передать в метод.

```cpp
void (A::*pf) ();
pf = &A::f; // Просто A::f не значит получить адрес, это просто указывает что f - член класса A. Поэтому получаем адрес.
A obj;
A *p = &obj;
(obj.*pf)(); // чтобы вызвать метод pf с использованием this == &obj
(p->*pf)();
```

Приоритет .* и -> ниже, чем у оператора *, поэтому ставятся скобочки. Они оба относятся к бинарным операторам. Просто -> унарный оператор.

## Правила перегрузки операторов.

1. Операторы можем перегружать или как член класса, или как внешний оператор. 
2. Мы не можем определять оператор с модификатором static, за исключением new и delete, поскольку они по умолчанию статические.
3. Унарные операторы можно перегружать как внешние, так и как члены класса, но желательно как члены класса. Бинарный оператор можно перегружать как член, и есть ситуации, когда надо перегружать как внешние.

## Перегрузка операторов `=` (и группа), `()` (круглые скобочки, функутор) и `[ ]` и '->', '->*'

Их надо всегда перегружать как члены класса. 

#### `=`

Оператор присваивания должен возвращать или ссылку на объект, или ничего. Как правило, если хотим использовать присваивание в выражениях,то лучше возвращать ссылку на себя. 

Про оператор присваивания с переносом: операция простая, единственное, может будет вызваться деструктор на объект, поэтому должен стоять noexcept.

#### `()`

Его вызывают для объекта, его вызов похож на вызов функции. Бинарный оператор. Например:
```cpp
A obj;
obj(...);
```
По существу работаем с объектом как с функцией. Возвращать он может что угодно. Этот оператор для класса можно перегружать, то есть определять несколько функторов в одном классе. На примере ниже он заменяет компаратор.

#### `[]`

В ЯП С заменяет две операции: смещение с разыменованием, причём в Си он коммутативный и бинарный. При перегрузке лишаемся коммутативности этого оператора. Перегружая этот оператор можно создавать ассоциативные массивы, так как на параметр оператора не накладываются никакие ограничения. Можно перегружать как для константных, так и не константных объектов.

```cpp
class A
{
public:
    A& operator = (const A& a);
    A& operator = (A&& a) noexcept;
    int operator () (const A& a) const {return compare(*this, a);};
    Elem_t &operator [] (int index);
};
```

#### `->`, `*`

```
class C
{
public:
    void f();
};

class B
{
    C *ptr;
public:
    C *operator ->() {return ptr;};
    C &operator *() {return *ptr};
};

int main()
{
    B obj(new C);
    obj->f(); // (obj.operator->())->f();
    (*obj).f()
}
```
То есть, благодаря этому делаем класс B прозрачной оболочкой, такие классы - посредники. В паре с этим оператором *. Оба операторы унарные. Их можно также перегружать для const объектов.

## Перегрузка ->*

```cpp
# include <iostream>

using namespace std;

class Callee
{
private:
    int index;

public:
    Callee(int i = 0) : index(i) {}

    int inc(int d) { return index += d; }
    int dec(int d) { return index -= d; }
};

class Caller
{
public:
    using FnPtr = int (Callee::*)(int);

private:
    Callee* pobj;
    FnPtr ptr;

public:
    Caller(Callee* p, FnPtr pf) : pobj(p), ptr(pf) {}

    int operator ()(int d) { return (pobj->*ptr)(d); }
};

class Pointer
{
private:
    Callee* pce;

public:
    Pointer(int i) { pce = new Callee(i); }
    ~Pointer() { delete pce; }

    Caller operator->*(Caller::FnPtr pf) { return Caller(pce, pf); }
};

int main()
{
    Caller::FnPtr pn = &Callee::inc;

    Pointer pt(1);

    cout << "Result: " << (pt->*pn)(2) << endl;
}
```