# 1.15. Ограничения накладываемые на шаблоны. Требования к шаблонам (requires). Концепты. Типы ограничений. Варианты определения шаблонов функций и классов с концептами.

В 20 стандарте можно накладывать ограничения на параметры шаблонов. 

`template<typename T> requires <требования>`

Что может быть требованием:
* выражение, выполняемые на этапе компиляции
* Это могут быть функции, которые выполняются на этапе компиляции (constexpr, модификатор требует, чтобы эта функция вычислялась на этапе компиляции)
* блоки requires. Может не вычисляется, только проверяться. Например, нужно чтобы в классе были определённые методы. Это не вычисляемая вещь, это требование.
* концепты

Эти функции могут выполняться или нет. Если они не выполняются - шаблон не подходит. Но также они могут возвращать значение true|false. false - шаблон не подходит.

Между этим всем можно ставить конъюнкцию (&&) и/или дизъюнкцию (||).

## Концепты

```
template<typename T>
concept <имя> = <требования шаблона, для которого устанавливаем>
```

Виды ограничений концептов:
1. Простые
2. Составные
3. Типовые
4. Вложенные

```cpp
template <typename T>
concept Incrementable = requires (T t, T t1)
{
    ++t; // Простые ограничения
    t++;
    { t == t1} -> std::convertible_to<bool>; // Сложные ограничения. Требовнаия на тип результата выражения.
    // Тип. рез. должен преобр к bool. Или жёстко задать ограничени: std::same_as<bool>
    typename T::value_type; // Ограничения по типу
    // Вложенный requires
    requires noexcept(++t); // noexcept, поскольку все остальные ограничения проверяемы, а это вычисляемое
};
```

# Варианты определения шаблонов функций и классов с концептами.

Ограничения можно накладывать на функции и классы. Для ограничения на функции есть 4 варианта ограничений.

1.
```cpp
template <typename T> requires incrementable<T>
    T &inc(T &v) {return ++v;}
```
2.
```cpp
template <typename T> 
T &inc(T &v) requires incrementable<T> {return ++v;}
```
3. Можно непосредственно наложить концепт на параметр шаблона. Происходит срезание этого параметра. Однако, если концепт содержит несколько параметров, то срезается первый параметр.
```cpp
template <Incrementable T>
T &inc(T &v) {return ++v;}
```
4. 
```cpp
auto &inc(Incrementable auto &v);
```

А для классов только два варианта, 1 и 3. 

Концепты внутри концептов делать нельзя. На концепт не обязательно блок requires, можно перечислять функции или другие концепты, используя конъюнкцию или дизнъюнкцию.