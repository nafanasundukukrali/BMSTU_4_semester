# 1.3. Классы и объекты в С++. Определение класса с помощью class, struct, union. Ограничение доступа к членам класса в С++. Члены класса и объекта. Методы класса и объекта. Константные члены класса. Схемы наследования.

> Первая идея Хоара: объединение данных и действий над этими данными.

## Классы

### struct

Есть структура, в ней есть поля-члены. Почему бы не добавить в эту структуры функции по работе с данными? Идя была в том, чтобы работать извне только с действиями. Если начинаем извне работать с членами-данными, то теряется вся идея ООП. С 11 стандарта структура всегда класс. По умолчанию уровень доступа к членам public.

### class
Уровень доступа по умолчанию private.

```
class <type>: [ list of parent ]
{
private:
<members>
protected:
<members>
public:
<members>
}
```

В каком порядке располагать члены? Если разработка private, protected, public, а если класс будет использовать кто-то другой (библиотечный класс), то в обратном порядке.

### union
По умолчанию уровень доступа к членам public. В union нет уровня protected, так как union не может быть ни базовым классом,
ни производным.

## Ограничение доступа к членам класса в С++.
#### private (частный)
Те члены, к которым будут иметь доступ только функции, которые выделены для работы с объектами этого класса/класса. Доступ извне запрещён. Все члены-данные должны иметь уровень доступа этот (редко защищённый). 
#### protected (защищённый)
Те члены, к которым имеет доступ производные класса. 
#### public (общий)
Уровень интерфейса, это методы.

## Схемы наследования

```cpp
class A
{
private:
    int a;
protected:
    int b;
public:
    int f();
};
```

Можно от класса А породить производный класс В. В языке C++ используются схемы наследования, аналогичные уровням доступа. 

```cpp
class B: <схема наследования> A
{
private:
    int c;
protected:
    int d;
public:
    int g();
}
```
#### private
При этой схеме наследования все члены базового класса получат уровень доступа private. 
Пикча-смысл: a - уже имеет private, в B к нему не будет доступа. Извне доступ только в g(). Базовый класс в шутку называют папой, он ничего не знает о произвольных.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_3_1.png)

Что даёт схема наследования? Полная смена интерфейса.

#### protected

При этой схеме наследования все public члены базового класса получают уровень доступа protected. 

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_3_2.png)

Что даёт эта схема? Также полная смена интерфейса, но оставили интерфейс базового класса доступным для классов, которые будут произвольные для класса B.

#### public

Все члены наследуются с их уровнем доступа.

![](https://github.com/nafanasundukukrali/BMSTU_4_semester/blob/main/images/1_3_3.png)

Что даёт эта схема? Расширение интерфейса, базовый интерфейс остаётся для доступа извне.

А если хочется, чтобы какие-то методы были публично доступные, а какие-то нет? При схеме protected или private можно восстановить уровень доступа базовых членов. Использовать `using A::f`. Так методов с именем f может быть несколько, то уровень доступа поменяется вообще для всех них. Вся перегрузка должна перейти в произвольный класс. Почему так сделали? 

С наследованием неразрывно понятие полиморфизм. В современных языках есть только public-наследование, поскольку если поменяем интерфейс старый код не сможет работать с объектами класса. Поэтому желательно, чтобы произвольные классы поддерживали интерфейс базового класса.

```cpp
class B: private A
{
private:
    int c;
protected:
    int d;
public:
    int g();
    using A::f;
};
```
## Члены класса и объекта. Методы класса и объекта.

Члены класса - это те члены, который не относятся к конкретному объекту, они общие для всех объектов данного класса. Перед такими членами ставится ключевое слово static. Статические члены, в общем-то, к объекту не относятся. Например, если создать объект класса и вызвать sizeof(), то статические члены учитываться не будут, память под распределяется не в объекте, память выделяется под них изначально, хранятся они в сегменте данных. Можно работать со статическими членами, не создав ни одного объекта данного класса. Статический метод имеет доступ ко всем объектам своего класса. Начиная с 11 стандарта по умолчанию можно инициализировать любой член класса, не только константные, статические.

```cpp
class A
{
private:
    int i;
public:
    A(): i(2) {};
    static void f() {std::cout << "f";};
    static void g(A &obj) {std::cout << obj.i;};
};

int main()
{
    A::f(); // f
    A obj;
    A::g(obj); // 2
    return 0;
}
```

## Константные члены класса.

Может быть поле-член объекта константа. 

Не точная, но вроде информация:

```cpp
class A
{
private:
int i; // Здесь уйдёт в кучу/стек при создании объекта
const int ci = i; // Это тоже уйдёт в кучу/стек при создании объекта, = i компилируется, константа времени выполнения
static int si; // секция .data
static const int sci = 2; // секция .rodata, константа времени компиляции
}
```

## Операторы доступа к методам извне

`.`, `->`, `::`

Оператор точка выбирает член из объекта типа класса; оператор стрелка определен так, что код ptr->mem эквивалентен коду (*ptr).mem. 
Есть ещё два - операторы доступ к методу через указатель на метод
`.*`, `->*`

Зачем? Вызываем по указателю метод, но метод, если это метод объекта, то должен принять указатель на объект (указатель this).

```cpp
#include <iostream.h>
class myclass {
public:
int sum;
void myclass::sum_it(int x) {};
};


int main()
{
int myclass::*dp; // указатель на целочисленный член
void (myclass::*fp) (int x); // указатель на функцию-член
myclass *c, d; // с теперь указатель на объект
с = &d; // с получает адрес объекта
dp = &myclass::sum; // получение адреса данных
fp = &myclass::sum_it; // получение адреса функции
(c->*fp) (7); // использование ->* для вызова функции
return 0;
}
```